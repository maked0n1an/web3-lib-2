from abc import (
    ABC, abstractmethod
)
from typing import (
    Generic, List, Type, TypeVar
)
from sqlalchemy import select, insert
from sqlalchemy.exc import IntegrityError
from sqlalchemy.ext.asyncio import AsyncSession

from ..models import SqlBaseModel


TEntity = TypeVar("TEntity", bound=SqlBaseModel)


class GenericRepository(Generic[TEntity], ABC):
    @abstractmethod
    async def get(self, id: int) -> TEntity | None:
        raise NotImplementedError()
    
    @abstractmethod
    async def get_with_filters(self, filters: dict) -> TEntity | None:
        raise NotImplementedError()

    @abstractmethod
    async def get_all(self, filters) -> List[TEntity] | None:
        raise NotImplementedError()

    @abstractmethod
    async def get_all_with_filters(self, filters: dict) -> List[TEntity]:
        raise NotImplementedError()

    @abstractmethod
    async def add(self, entity: TEntity) -> int:
        raise NotImplementedError()

    @abstractmethod
    async def add_all(self, entities: List[TEntity]) -> List[int]:
        raise NotImplementedError()

    @abstractmethod
    async def update(self, entity: TEntity) -> int:
        raise NotImplementedError()

    @abstractmethod
    async def delete(self, id: int) -> bool:
        raise NotImplementedError()


class GenericSqlAlchemyRepository(GenericRepository[TEntity]):
    def __init__(self, session: AsyncSession, model_cls: Type[TEntity]):
        self.__session = session
        self.model_cls = model_cls

    async def get(self, id: int) -> TEntity | None:
        return await self.__session.get(self.model_cls, id)

    async def get_with_filters(self, filters: dict) -> TEntity | None:
        query = select(self.model_cls).filter_by(**filters).limit(1)
        result = await self.__session.execute(query)
        record = result.scalar_one_or_none()
        return record
        # query = self._construct_search_query(**filters).limit(1)
        # return (await self.__session.execute(query)).scalar_one_or_none()

    async def get_all(self) -> List[TEntity] | None:
        return await self.get_all_with_filters({})

    async def get_all_with_filters(self, filters: dict) -> List[TEntity]:
        query = select(self.model_cls).filter_by(**filters)
        result = await self.__session.execute(query)
        records = result.scalars().all()
        return records
        # query = self._construct_search_query(**filters)
        # return (await self.__session.execute(query)).scalars().all()

    async def add(self, entity: TEntity) -> int:
        """
        Adds a new entity to the database.

        This method adds the provided entity to the session and flushes the session to 
        ensure the entity is persisted in the database. If the entity has an id specified, 
        it will be added with that id. Otherwise, a new id will be generated by the database.

        Args:
            entity (Model): The entity to be added to the database.

        Returns:
            int: The id of the added entity.
        """
        self.__session.add(entity)
        await self.__session.flush()
        return entity.id
        
    async def _execute_insert_some(
        self, 
        entities: List[TEntity], 
        returning: bool
    ) -> List[TEntity] | None:
        values = [entity.__dict__.items() for entity in entities]
        
        try:
            command = insert(self.model_cls).execution_options(render_nulls=True)
            if returning:
                command = command.returning(self.model_cls)
                
            result = await self.__session.execute(statement=command, params=[*values]) 
            await self.__session.flush()
            return (
                result.scalars().all()
                if returning
                else [entity.id for entity in entities]
            )
            
        except IntegrityError as e:
            str_error = str(e.orig)
            if 'UNIQUE constraint failed:' in str_error:
                constraint_name = str_error.split('UNIQUE constraint failed: ')[-1]
                raise(
                    "Can't add entity with the same"
                    f" value in {constraint_name}"
                )
            await self.__session.rollback()    

    async def add_all(
        self, 
        entities: List[TEntity]
    ) -> List[int]:
        """
        Adds a list of entities to the database.
        This method takes a list of entities, adds them to the session, and 
        flushes the session to ensure they are persisted in the database. 

        It returns a list of ids of the added entities.

        Args:
            entities (List[Model]): A list of entities to be added to the database.

        Returns:
            List[int]: A list of ids of the added entities.
        """
        await self._execute_insert_some(entities, False)

    async def add_all_and_return(
        self, 
        entities: List[TEntity]
    ) -> List[TEntity]:
        """
        Adds multiple entities to the database and returns them.

        This method takes a list of entities, adds them to the session, and 
        flushes the session to ensure they are persisted in the database. 
        It returns a list of the added entities.

        Args:
            entities (List[Model]): A list of entities to be added to the database.

        Returns:
            List[Model]: A list of the added entities.
        """
        return await self._execute_insert_some(entities, True)

    async def update(self, entity: TEntity) -> int:
        """
        Updates an existing entity with id (!) or creates a new one if it does not exist.

        This method uses the SQLAlchemy `merge` function to either update an existing 
        entity with the same id in the database or create a new entity if no such 
        entity exists. Return id

        Args:
            entity (Model): The entity to be updated or created.

        Returns:
            int: The updated or newly created entity's id.
        """
        await self.__session.merge(entity)
        await self.__session.flush()
        return entity.id

    async def delete(self, id: int) -> bool:
        db_record = await self.get(id)
        if not db_record: 
            return False
        
        await self.__session.delete(db_record)
        await self.__session.flush()
        return True
    
    # def _construct_search_query(self, **filters):
    #     query = select(self.__model_cls)
    #     where_clauses = []
    #     for attr, value in filters.items():
    #         if not hasattr(self.__model_cls, attr):
    #             raise ValueError(f'Invalid column name {attr}')
    #         where_clauses.append(getattr(self.__model_cls, attr) == value)

    #     if len(where_clauses) == 1:
    #         query = query.where(where_clauses[0])
    #     elif len(where_clauses) > 1:
    #         query = query.where(and_(*where_clauses))

    #     return query

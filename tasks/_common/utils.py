import asyncio
import random
from dataclasses import dataclass
from typing import Union, Any

from curl_cffi.requests import AsyncSession

from libs.async_eth_lib.architecture.client import EvmClient
from libs.async_eth_lib.architecture.network import Network
from libs.async_eth_lib.data.token_contracts import ContractsFactory
from libs.async_eth_lib.models.others import LogStatus, TokenAmount, TokenSymbol
from libs.async_eth_lib.models.operation import OperationInfo


@dataclass
class FromTo:
    from_: Union[int, float]
    to_: Union[int, float]


# region To construct tx
class HashUtils:
    @staticmethod
    def to_cut_hex_prefix_and_zfill(hex_data: str, length: int = 64):
        """
        Convert the hex string to lowercase, remove the '0x' prefix, and fill it with zeros to the specified length.

        Args:
            hex_data (str): The original hex string.
            length (int): The desired length of the string after filling. The default is 64.

        Returns:
            str: The modified string with '0x' prefix removed and zero-filled to the specified length.
        """
        if hex_data.startswith('0x'):
            hex_data = hex_data[2:]
        else:
            raise ValueError("Hex data must start with '0x'")

        return hex_data.zfill(length)

    @staticmethod
    def zfill_hex_value(hex_value: str, length: int = 64) -> str:
        hex_value = HashUtils.to_cut_hex_prefix_and_zfill(hex_value, length)
        return '0x' + hex_value


# region To get prices
class PriceUtils:
    STABLES = [
        TokenSymbol.USDT,
        TokenSymbol.USDC,
        TokenSymbol.USDC_E,
        TokenSymbol.USDV
    ]

    @staticmethod
    async def get_cex_price(
        first_token: str = TokenSymbol.ETH,
        second_token: str = TokenSymbol.USDT
    ) -> float | None:
        first_token = (
            first_token.lstrip('W')
            if len(first_token) > 2
            else first_token
        )
        second_token = (
            second_token.lstrip('W')
            if len(second_token) > 2
            else second_token
        )

        if first_token in PriceUtils.STABLES and second_token in PriceUtils.STABLES:
            return 1.0

        async with AsyncSession() as session:
            tasks = [
                PriceUtils._get_price_from_binance(
                    session, first_token, second_token),
                PriceUtils._get_price_from_cryptocompare(
                    session, first_token, second_token)
            ]

            for price in await asyncio.gather(*tasks, return_exceptions=True):
                if isinstance(price, float):
                    return price

            raise ValueError(
                f'Could not get {first_token}{second_token} price from Binance or Cryptocompare'
            )

    @staticmethod
    async def _get_price_from_binance(
        session: AsyncSession,
        first_token: str,
        second_token: str
    ) -> float | None:
        first_token, second_token = first_token.upper(), second_token.upper()
        for _ in range(5):
            try:
                response = await session.get(
                    f'https://api.binance.com/api/v3/ticker/price?symbol={first_token}{second_token}')
                if response.status_code == 200:
                    result_dict = response.json()
                    if 'price' in result_dict:
                        return float(result_dict['price'])
                return None
            except Exception:
                await asyncio.sleep(1)

    @staticmethod
    async def _get_price_from_cryptocompare(
        session: AsyncSession,
        first_token: str,
        second_token: str
    ) -> float | None:
        first_token, second_token = first_token.upper(), second_token.upper()
        for _ in range(5):
            try:
                response = await session.get(
                    f'https://min-api.cryptocompare.com/data/price?fsym={first_token}&tsyms={second_token}'
                )
                if response.status_code == 200:
                    result_dict = response.json()
                    return float(result_dict[second_token])
                return None
            except Exception:
                await asyncio.sleep(1)
# endregion To get prices


# region BaseSettings
# Class for autogenerate settings.
class StandardSettings:
    """
    Autogenerated settings.

    Args:
        settings (dict): The settings dictionary loaded from a JSON file.
        module_name (str): The module name.
        action_name (str): The action name.

    Attributes:
        action_name (str): The name of the action.
        eth_amount (FromTo | None): The range of ETH amounts for the action, if specified.
        eth_amount_percent (FromTo | None): The percentage range of ETH amounts, if specified.
        token_amount (FromTo | None): The range of token amounts for the action, if specified.
        token_amount_percent (FromTo | None): The percentage range of token amounts, if specified.

    Example of use:
    >>> class StargateSettings:
    >>>     def __init__(self):
    >>>         settings = read_json(path=MODULES_SETTINGS_FILE_PATH)
    >>>         self.bridge = StandardSettings(
    >>>             settings=settings,
    >>>             module_name='stargate',
    >>>             action_name='bridge'
    >>>         )
    >>>         self.liquidity = StandardSettings(
    >>>             settings=settings,
    >>>             module_name='stargate',
    >>>             action_name='liquidity'
    >>>         )
    >>>         ...
    """

    def __init__(
        self,
        settings: dict,
        module_name: str,
        action_name: str
    ):
        action_settings: dict = settings[module_name][action_name]
        from_ = 'from'
        to_ = 'to'
        min_percent = 'min_percent'
        max_percent = 'max_percent'

        self.action_name = action_name
        self.eth_amount = self.init_from_to(
            action_settings, 'eth_amount', from_, to_
        )
        self.eth_amount_percent = self.init_from_to(
            action_settings, 'eth_amount', min_percent, max_percent
        )
        self.token_amount = self.init_from_to(
            action_settings, 'token_amount', from_, to_)
        self.token_amount_percent = self.init_from_to(
            action_settings, 'token_amount', min_percent, max_percent
        )

        if 'slippage' in action_settings:
            self.slippage = float(action_settings['slippage'])
        if 'max_fee_in_usd' in action_settings:
            self.max_fee_in_usd = float(action_settings['max_fee_in_usd'])

    def init_from_to(
        self,
        section: dict[str, dict],
        key: str,
        upper_bound: str,
        lower_bound: str,
    ) -> FromTo | None:
        from_value = section[key].get(upper_bound)
        to_value = section[key].get(lower_bound)

        if from_value or to_value:
            return FromTo(
                from_=from_value,
                to_=to_value,
            )
        return None


# region RandomChoice
class RandomChoiceHelper:
    '''To get random token from available options for operation'''
    @staticmethod
    async def get_partial_operation_info_and_dst_data(
        op_data: dict[Network, dict[str, list[Any]]],
        op_settings: StandardSettings,
        client: EvmClient,
    ) -> tuple[OperationInfo | None, list | None]:
        tokens_dict = list(op_data[client.network].keys())
        random.shuffle(tokens_dict)

        partial_op = dst_data = None

        for src_token_sym in tokens_dict:
            partial_op = await RandomChoiceHelper.get_partial_operation_info(
                token_name=src_token_sym,
                op_settings=op_settings,
                client=client
            )

            if partial_op:
                dst_data = op_data[client.network][partial_op.from_token_name]

                client.custom_logger.log_message(
                    status=LogStatus.INFO,
                    message=(
                        f'Found {partial_op.amount} '
                        f'{partial_op.from_token_name} for {op_settings.action_name}()'
                    ),
                    call_depth_or_custom_call_place=2
                )
                break

        return partial_op, dst_data

    @staticmethod
    async def get_partial_operation_info(
        token_name: str,
        op_settings: StandardSettings,
        client: EvmClient,
    ) -> OperationInfo | None:
        token_contract = ContractsFactory.get_contract(
            client.network.name, token_name
        )

        if token_contract.is_native_token:
            balance_wei = await client.contract.get_balance()
            decimals = await client.contract.get_decimals()

            amount_setting = op_settings.eth_amount
            amount_percent_setting = op_settings.eth_amount_percent
        else:
            balance_wei = await client.contract.get_balance(token_contract.address)
            decimals = await client.contract.get_decimals(token_contract)

            amount_setting = op_settings.token_amount
            amount_percent_setting = op_settings.token_amount_percent

        balance = TokenAmount(
            amount=balance_wei,
            decimals=decimals,
            wei=True
        )

        if amount_setting and float(balance.Ether) > amount_setting.from_:
            amount_setting.to_ = min(float(balance.Ether), amount_setting.to_)

            return OperationInfo(
                from_token_name=token_name,
                amount_from=amount_setting.from_,
                amount_to=amount_setting.to_
            )
        if amount_percent_setting and balance.Ether > 0:
            op_info = OperationInfo(
                from_token_name=token_name,
                min_percent=amount_percent_setting.from_,
                max_percent=amount_percent_setting.to_
            )
            op_info.amount = op_info.amount_by_percent * float(balance.Ether)
            return op_info

        return None
# endregion RandomChoice

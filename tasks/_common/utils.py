import asyncio
import random
from decimal import Decimal
from typing import Any, Optional

from curl_cffi.requests import AsyncSession

from libs.async_eth_lib.architecture.client import EvmClient
from libs.async_eth_lib.architecture.network import Network
from libs.async_eth_lib.data.token_contracts import ContractsFactory
from libs.async_eth_lib.models.others import LogStatus, TokenAmount, TokenSymbol
from libs.async_eth_lib.models.operation import OperationInfo
from libs.pretty_utils.type_functions.dataclasses import FromTo


# region To construct tx
class Utils:
    @staticmethod
    def to_cut_hex_prefix_and_zfill(hex_data: str, length: int = 64):
        """
        Convert the hex string to lowercase, remove the '0x' prefix, and fill it with zeros to the specified length.

        Args:
            hex_data (str): The original hex string.
            length (int): The desired length of the string after filling. The default is 64.

        Returns:
            str: The modified string with '0x' prefix removed and zero-filled to the specified length.
        """
        if hex_data.startswith('0x'):
            hex_data = hex_data[2:]
        else:
            raise ValueError("Hex address must start with '0x'")

        return hex_data.zfill(length)

    @staticmethod
    def normalize_non_evm_hex_value(hex_value: str, length: int = 64) -> str:
        hex_value = Utils.to_cut_hex_prefix_and_zfill(hex_value, length)
        return '0x' + hex_value


# region To get prices
class PriceUtils:
    STABLES = {
        TokenSymbol.USDT:   1.0,
        TokenSymbol.USDC:   1.0,
        TokenSymbol.USDC_E: 1.0,
        TokenSymbol.USDV:   1.0
    }

    async def get_binance_price(
        self,
        first_token: str = TokenSymbol.ETH,
        second_token: str = TokenSymbol.USDT
    ) -> float | None:
        first_token = first_token.lstrip('W')
        second_token = second_token.lstrip('W')

        if first_token in self.STABLES and second_token in self.STABLES:
            return 1.0

        async with AsyncSession() as session:
            price = await self._get_price_from_binance(session, first_token, second_token)
            if price:
                return price
            else:
                return await self._get_price_from_binance(session, second_token, first_token)

    async def _get_price_from_binance(
        self,
        session: AsyncSession,
        first_token: str,
        second_token: str
    ) -> float | None:
        first_token, second_token = first_token.upper(), second_token.upper()
        for _ in range(5):
            try:
                response = await session.get(
                    f'https://api.binance.com/api/v3/ticker/price?symbol={first_token}{second_token}')
                if response.status_code != 200:
                    return None
                result_dict = response.json()
                if 'price' in result_dict:
                    return float(result_dict['price'])
            except Exception as e:
                await asyncio.sleep(2)
        raise ValueError(
            f'Can not get {first_token}{second_token} price from Binance')
# endregion To get prices


# region BaseSettings
# Class for autogenerate settings.
class StandardSettings:
    """
    Autogenerated settings.

    Args:
        settings (dict): The settings dictionary loaded from a JSON file.
        module_name (str): The module name.
        action_name (str): The action name.

    Attributes:
        action_name (str): The name of the action.
        eth_amount (FromTo | None): The range of ETH amounts for the action, if specified.
        eth_amount_percent (FromTo | None): The percentage range of ETH amounts, if specified.
        token_amount (FromTo | None): The range of token amounts for the action, if specified.
        token_amount_percent (FromTo | None): The percentage range of token amounts, if specified.

    Example of use:
    >>> class StargateSettings:
    >>>     def __init__(self):
    >>>         settings = read_json(path=MODULES_SETTINGS_FILE_PATH)
    >>>         self.bridge = StandardSettings(
    >>>             settings=settings,
    >>>             module_name='stargate',
    >>>             action_name='bridge'
    >>>         )
    >>>         self.liquidity = StandardSettings(
    >>>             settings=settings,
    >>>             module_name='stargate',
    >>>             action_name='liquidity'
    >>>         )
    >>>         ...
    """

    def __init__(
        self,
        settings: dict,
        module_name: str,
        action_name: str
    ):
        act_stgs: dict = settings[module_name][action_name]
        from_ = 'from'
        to_ = 'to'
        min_percent = 'min_percent'
        max_percent = 'max_percent'

        self.eth_amount = self.init_from_to(act_stgs, 'eth_amount', from_, to_)
        self.eth_amount_percent = self.init_from_to(
            act_stgs, 'eth_amount', min_percent, max_percent
        )

        self.token_amount = self.init_from_to(
            act_stgs, 'token_amount', from_, to_)
        self.token_amount_percent = self.init_from_to(
            act_stgs, 'token_amount', min_percent, max_percent
        )

        if 'slippage' in act_stgs:
            self.slippage = float(act_stgs['slippage'])
        if 'max_fee_in_usd' in act_stgs:
            self.max_fee_in_usd = float(act_stgs['max_fee_in_usd'])

    def init_from_to(
        self,
        section: dict[str, dict],
        key: str,
        upper_bound: str,
        lower_bound: str,
    ) -> FromTo | None:
        from_value = section[key].get(upper_bound)
        to_value = section[key].get(lower_bound)

        if from_value or to_value:
            return FromTo(
                from_=from_value,
                to_=to_value,
            )
        return None


# region RandomChoice
class RandomChoiceHelper:
    '''To get random token from available options for operation'''
    @staticmethod
    async def get_random_token_for_operation(
        op_name: str,
        op_data: dict[Network, dict[str, list[Any]]],
        op_settings: StandardSettings,
        client: EvmClient,
    ) -> tuple[Optional[OperationInfo], Optional[list[tuple]]]:
        tokens_dict = list(op_data[client.network].keys())
        random.shuffle(tokens_dict)

        operation_info = dst_data = None

        for src_token_sym in tokens_dict:
            token_contract = ContractsFactory.get_contract(
                client.network.name, src_token_sym
            )

            if token_contract.is_native_token:
                balance = await client.contract.get_balance()

                operation_info = RandomChoiceHelper._get_operation_info(
                    balance=balance,
                    amount_setting=op_settings.eth_amount,
                    amount_percent_setting=op_settings.eth_amount_percent,
                    token_name=src_token_sym
                )

            else:
                balance = await client.contract.get_balance(token_contract)

                operation_info = RandomChoiceHelper._get_operation_info(
                    balance=balance,
                    amount_setting=op_settings.token_amount,
                    amount_percent_setting=op_settings.token_amount_percent,
                    token_name=src_token_sym
                )

            if operation_info:
                dst_data = op_data[client.network][src_token_sym]

                if not operation_info.amount:
                    operation_info.amount = round(
                        float(Decimal(operation_info.amount_by_percent)
                              * balance.Ether),
                        token_contract.decimals
                    )

                client.custom_logger.log_message(
                    status=LogStatus.INFO,
                    message=(
                        f'Found {operation_info.amount} '
                        f'{operation_info.from_token_name} for {op_name}()'
                    ),
                    call_depth_or_custom_call_place=2
                )
                break

        return operation_info, dst_data

    @staticmethod
    def _get_operation_info(
        balance: TokenAmount,
        token_name: str,
        amount_setting: Optional[FromTo] = None,
        amount_percent_setting: Optional[FromTo] = None,
    ) -> Optional[OperationInfo]:
        if (
            amount_setting
            and
            float(balance.Ether) > amount_setting.from_
        ):
            if amount_setting.to_ != 0:
                upper_bound = min(float(balance.Ether), amount_setting.to_)
            else:
                upper_bound = float(balance.Ether)

            return OperationInfo(
                from_token_name=token_name,
                amount_from=amount_setting.from_,
                amount_to=upper_bound
            )

        if (
            amount_percent_setting
            and balance.Ether != 0
            and not amount_setting
        ):
            return OperationInfo(
                from_token_name=token_name,
                min_percent=amount_percent_setting.from_,
                max_percent=amount_percent_setting.to_
            )
        return None
# endregion RandomChoice

